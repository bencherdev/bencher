import FizzBuzzFibonacciOpenRules from "../../benchmarking/de/fizz-buzz-fibonacci-open-rules.mdx";
import FizzBuzzFibonacciOpenRustCode from "../fizz-buzz-fibonacci-open-rust-code.mdx";
import FizzBuzzFibonacciOpenRustOutput from "../fizz-buzz-fibonacci-open-rust-output.mdx";
import FizzBuzzFibonacciOpenRustOutputDefault from "../fizz-buzz-fibonacci-open-rust-output-default.mdx";

## Erweiterung von FizzBuzzFibonacci in Rust

Unser Spiel ist ein Hit! Die Kinder lieben es wirklich, FizzBuzzFibonacci zu spielen.
So sehr, dass von den Gesch√§ftsf√ºhrern die Nachricht kam, dass sie eine Fortsetzung wollen.
Aber das ist die moderne Welt, wir brauchen j√§hrlich wiederkehrende Einnahmen (ARR) anstatt einmaliger K√§ufe!
Die neue Vision f√ºr unser Spiel ist, dass es offen endet, kein Leben mehr zwischen der Begrenzung von `1` und `100` (auch wenn es inklusive ist).
Nein, wir sind auf zu neuen Fronten!

<FizzBuzzFibonacciOpenRules />

Um unser Spiel f√ºr jede Zahl funktionieren zu lassen, werden wir ein Kommandozeilenargument akzeptieren m√ºssen.
Aktualisieren Sie die `main` Funktion, um so auszusehen:

<FizzBuzzFibonacciOpenRustCode />

- Sammeln Sie alle Argumente (`args`), die unserer Spiel von der Kommandozeile aus √ºbergeben werden.
- Nehmen Sie das erste Argument, das zu unserem Spiel √ºbergeben wird, und analysieren Sie es als eine vorzeichenlose Ganzzahl `i`.
- Wenn das Parsen fehlschl√§gt oder kein Argument √ºbergeben wird, fahren Sie standardm√§√üig mit unserem Spiel mit `15` als Eingang fort.
- Spielen Sie schlie√ülich unser Spiel mit der neu analysierten vorzeichenlosen Ganzzahl `i`.

Jetzt k√∂nnen wir unser Spiel mit jeder Zahl spielen!
Verwenden Sie `cargo run` gefolgt von `--` um Argumente an unser Spiel zu √ºbergeben:

<FizzBuzzFibonacciOpenRustOutput />

Und wenn wir eine Zahl weglassen oder eine ung√ºltige Zahl angeben:

<FizzBuzzFibonacciOpenRustOutputDefault />

Wow, das war ein gr√ºndlicher Test! CI besteht. Unsere Chefs sind begeistert.
Lasst uns es ausliefern! üöÄ