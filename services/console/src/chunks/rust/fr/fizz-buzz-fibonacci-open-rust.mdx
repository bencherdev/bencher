import FizzBuzzFibonacciOpenRules from "../../benchmarking/fr/fizz-buzz-fibonacci-open-rules.mdx";
import FizzBuzzFibonacciOpenRustCode from "../fizz-buzz-fibonacci-open-rust-code.mdx";
import FizzBuzzFibonacciOpenRustOutput from "../fizz-buzz-fibonacci-open-rust-output.mdx";
import FizzBuzzFibonacciOpenRustOutputDefault from "../fizz-buzz-fibonacci-open-rust-output-default.mdx";

## √âtendre FizzBuzzFibonacci en Rust

Notre jeu est un succ√®s! Les enfants adorent jouer √† FizzBuzzFibonacci.
Tellement que les dirigeants veulent une suite.
Mais c'est le monde moderne, nous avons besoin de revenus r√©currents annuels (ARR) et non de ventes uniques!
La nouvelle vision de notre jeu est qu'il est sans fin, plus besoin de vivre entre les limites de `1` et `100` (m√™me si c'est inclusif).
Non, nous partons vers de nouveaux horizons!

<FizzBuzzFibonacciOpenRules />

Pour faire fonctionner notre jeu pour n'importe quel nombre, nous devrons accepter un argument de ligne de commande.
Mettez √† jour la fonction `main` pour qu'elle ressemble √† ceci :

<FizzBuzzFibonacciOpenRustCode />

- Collectez tous les arguments (`args`) pass√©s √† notre jeu depuis la ligne de commande.
- Obtenez le premier argument pass√© √† notre jeu et analysez-le comme un entier non sign√© `i`.
- Si l'analyse √©choue ou si aucun argument n'est transmis, par d√©faut, jouez √† notre jeu avec `15` comme entr√©e.
- Enfin, jouez √† notre jeu avec le nouvel entier non sign√© `i` analys√©.

Maintenant, nous pouvons jouer √† notre jeu avec n'importe quel nombre!
Utilisez `cargo run` suivi de `--` pour passer des arguments √† notre jeu :

<FizzBuzzFibonacciOpenRustOutput />

Et si nous oublions de fournir un num√©ro ou fournissons un num√©ro invalide :

<FizzBuzzFibonacciOpenRustOutputDefault />

Wow, c'√©tait des tests tr√®s approfondis! CI passe. Nos patrons sont ravis.
Exp√©dions-le! üöÄ