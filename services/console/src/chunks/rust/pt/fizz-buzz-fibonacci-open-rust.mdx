import FizzBuzzFibonacciOpenRules from "../../benchmarking/pt/fizz-buzz-fibonacci-open-rules.mdx";
import FizzBuzzFibonacciOpenRustCode from "../fizz-buzz-fibonacci-open-rust-code.mdx";
import FizzBuzzFibonacciOpenRustOutput from "../fizz-buzz-fibonacci-open-rust-output.mdx";
import FizzBuzzFibonacciOpenRustOutputDefault from "../fizz-buzz-fibonacci-open-rust-output-default.mdx";

## Expandindo FizzBuzzFibonacci em Rust

Nosso jogo √© um sucesso! As crian√ßas realmente adoram jogar FizzBuzzFibonacci.
Tanto que a dire√ß√£o quer uma sequ√™ncia.
Mas vivemos em um mundo moderno, precisamos de Receita Anual Recorrente (ARR) e n√£o de compras √∫nicas!
A nova vis√£o para o nosso jogo √© que ele seja aberto, sem mais viver entre os limites de `1` e `100` (mesmo que inclusivo).
N√£o, estamos partindo para novas fronteiras!

<FizzBuzzFibonacciOpenRules />

Para que nosso jogo funcione para qualquer n√∫mero, precisaremos aceitar um argumento de linha de comando.
Atualize a fun√ß√£o `main` para ficar assim:

<FizzBuzzFibonacciOpenRustCode />

- Colete todos os argumentos (`args`) passados para o nosso jogo a partir da linha de comando.
- Pegue o primeiro argumento passado para o nosso jogo e analise-o como um inteiro n√£o assinado `i`.
- Se a an√°lise falhar ou nenhum argumento for passado, use por padr√£o o nosso jogo com `15` como entrada.
- Finalmente, jogue nosso jogo com o novo inteiro n√£o assinado `i` analisado.

Agora podemos jogar nosso jogo com qualquer n√∫mero!
Use `cargo run` seguido de `--` para passar argumentos para o nosso jogo:

<FizzBuzzFibonacciOpenRustOutput />

E se omitirmos ou fornecermos um n√∫mero inv√°lido:

<FizzBuzzFibonacciOpenRustOutputDefault />

Nossa, que teste completo! O CI passou. Nossos chefes est√£o entusiasmados.
Vamos lan√ß√°-lo! üöÄ
