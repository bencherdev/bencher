/*
 Generated by typeshare 1.13.2
*/

export type BenchmarkName = string;

/** A benchmark UUID, slug, or name. */
export type BenchmarkNameId = Uuid | Slug | string;

/** An benchmark UUID or slug. */
export type BenchmarkResourceId = Uuid | Slug;

export type Boundary = number;

export type BranchName = string;

/** A branch UUID, slug, or name. */
export type BranchNameId = Uuid | Slug | string;

/** An branch UUID or slug. */
export type BranchResourceId = Uuid | Slug;

export type CardCvc = string;

export type CardNumber = string;

export type Cpu = number;

export type DateTime = string;

export type DateTimeMillis = number;

export type Email = string;

export type Entitlements = number;

export type ExpirationMonth = number;

export type ExpirationYear = number;

export type GitHash = string;

export type GracePeriod = number;

export type HeartbeatTimeout = number;

/**
 * An OCI image digest in the format `algorithm:hex`.
 * 
 * Supports:
 * - `sha256:` followed by 64 hex characters
 * - `sha512:` followed by 128 hex characters
 */
export type ImageDigest = string;

export type Index = number;

export type Iteration = number;

/** Job status */
export enum JobStatus {
	Pending = "pending",
	Claimed = "claimed",
	Running = "running",
	Completed = "completed",
	Failed = "failed",
	Canceled = "canceled",
}

export type ResourceName = string;

export enum Architecture {
	X86_64 = "x86_64",
	Aarch64 = "aarch64",
}

/** A hardware spec */
export interface JsonSpec {
	uuid: Uuid;
	name: ResourceName;
	slug: Slug;
	/** CPU architecture */
	architecture: Architecture;
	cpu: number;
	memory: number;
	disk: number;
	network: boolean;
	fallback?: string;
	created: string;
	modified: string;
	archived?: string;
}

export type Url = string;

export type Timeout = number;

/**
 * Job configuration sent to runners.
 * 
 * Contains the execution details needed for a runner to execute a job.
 * Designed to minimize data leakage - runners only learn what's necessary
 * to pull and execute an OCI image. Resource requirements (cpu, memory,
 * disk, network) are in the associated spec.
 */
export interface JsonJobConfig {
	/** Registry URL for pulling the OCI image (e.g., `https://registry.bencher.dev`) */
	registry: Url;
	/** Project UUID for OCI authentication scoping */
	project: Uuid;
	/** Image digest - must be immutable (e.g., "sha256:abc123...") */
	digest: ImageDigest;
	/** Entrypoint override (like Docker ENTRYPOINT) */
	entrypoint?: string[];
	/** Command override (like Docker CMD) */
	cmd?: string[];
	/** Environment variables passed to the container */
	env?: Record<string, string>;
	/** Maximum execution time in seconds */
	timeout: Timeout;
	/** File paths to read from the VM after job completion */
	file_paths?: string[];
	/** Benchmark harness suggested central tendency */
	average?: JsonAverage;
	/** Number of benchmark iterations for the runner to execute */
	iter?: Iteration;
	/** Fold operation for combining multiple iteration results */
	fold?: JsonFold;
	/** Allow benchmark failure without short-circuiting iterations */
	allow_failure?: boolean;
	/** Backdate the report start time */
	backdate?: string;
}

/** Output from a single benchmark iteration. */
export interface JsonIterationOutput {
	/** Exit code from the benchmark command */
	exit_code: number;
	/** Standard output from the benchmark */
	stdout?: string;
	/** Standard error from the benchmark */
	stderr?: string;
	/** File path to contents map */
	output?: Record<string, string> | undefined;
}

/** Job output stored in blob storage after job completion or failure. */
export interface JsonJobOutput {
	/** Per-iteration results */
	results: JsonIterationOutput[];
	/** Error message (present when the job failed). */
	error?: string;
}

/** A benchmark job */
export interface JsonJob {
	uuid: Uuid;
	status: JobStatus;
	/** Resource spec for this job */
	spec: JsonSpec;
	/** Job configuration (only included when claimed by a runner) */
	config?: JsonJobConfig;
	runner?: Uuid;
	claimed?: string;
	started?: string;
	completed?: string;
	created: string;
	modified: string;
	/** Job output (stdout, stderr, files) from blob storage, included for terminal jobs. */
	output?: JsonJobOutput;
}

/** A list of jobs */
export type JsonJobs = JsonJob[];

/** A measure UUID, slug, or name. */
export type MeasureNameId = Uuid | Slug | string;

export interface JsonNewMetric {
	value: number;
	lower_value?: number;
	upper_value?: number;
}

export type JsonMetricsMap = Record<MeasureNameId, JsonNewMetric>;

export interface JsonBenchmark {
	uuid: Uuid;
	project: Uuid;
	name: BenchmarkName;
	slug: Slug;
	created: string;
	modified: string;
	archived?: string;
}

export interface JsonMetric {
	uuid: Uuid;
	value: number;
	lower_value?: number;
	upper_value?: number;
}

export type VersionNumber = number;

export interface JsonVersion {
	number: VersionNumber;
	hash?: GitHash;
}

export interface JsonStartPoint {
	branch: Uuid;
	head: Uuid;
	version: JsonVersion;
}

export interface JsonHead {
	uuid: Uuid;
	start_point?: JsonStartPoint;
	version?: JsonVersion;
	created: string;
	replaced?: string;
}

export interface JsonBranch {
	uuid: Uuid;
	project: Uuid;
	name: BranchName;
	slug: Slug;
	head: JsonHead;
	created: string;
	modified: string;
	archived?: string;
}

export interface JsonTestbed {
	uuid: Uuid;
	project: Uuid;
	name: ResourceName;
	slug: Slug;
	spec?: JsonSpec;
	created: string;
	modified: string;
	archived?: string;
}

export interface JsonMeasure {
	uuid: Uuid;
	project: Uuid;
	name: ResourceName;
	slug: Slug;
	units: ResourceName;
	created: string;
	modified: string;
	archived?: string;
}

export enum ModelTest {
	Static = "static",
	Percentage = "percentage",
	ZScore = "z_score",
	TTest = "t_test",
	LogNormal = "log_normal",
	Iqr = "iqr",
	DeltaIqr = "delta_iqr",
}

export type SampleSize = number;

export type Window = number;

export interface JsonModel {
	uuid: Uuid;
	test: ModelTest;
	min_sample_size?: SampleSize;
	max_sample_size?: SampleSize;
	window?: Window;
	lower_boundary?: Boundary;
	upper_boundary?: Boundary;
	created: string;
	replaced?: string;
}

export interface JsonThreshold {
	uuid: Uuid;
	project: Uuid;
	branch: JsonBranch;
	testbed: JsonTestbed;
	measure: JsonMeasure;
	model?: JsonModel;
	created: string;
	modified: string;
}

export interface JsonBoundary {
	baseline?: number;
	lower_limit?: number;
	upper_limit?: number;
}

export enum BoundaryLimit {
	Lower = "lower",
	Upper = "upper",
}

export enum AlertStatus {
	/** The alert is active. */
	Active = "active",
	/** The alert has been dismissed by a user. */
	Dismissed = "dismissed",
	/** The alert has been silenced by the system. */
	Silenced = "silenced",
}

export interface JsonAlert {
	uuid: Uuid;
	report: Uuid;
	iteration: Iteration;
	benchmark: JsonBenchmark;
	metric: JsonMetric;
	threshold: JsonThreshold;
	boundary: JsonBoundary;
	limit: BoundaryLimit;
	status: AlertStatus;
	created: string;
	modified: string;
}

export type JsonReportAlerts = JsonAlert[];

export interface JsonThresholdModel {
	uuid: Uuid;
	project: Uuid;
	model: JsonModel;
	created: string;
}

export interface JsonReportMeasure {
	measure: JsonMeasure;
	metric: JsonMetric;
	threshold?: JsonThresholdModel;
	boundary?: JsonBoundary;
}

export interface JsonReportResult {
	iteration: Iteration;
	benchmark: JsonBenchmark;
	measures: JsonReportMeasure[];
}

export type JsonReportIteration = JsonReportResult[];

export type JsonReportResults = JsonReportIteration[];

export type JsonResultsMap = Record<BenchmarkName, JsonMetricsMap>;

/** A benchmark runner */
export interface JsonRunner {
	uuid: Uuid;
	name: ResourceName;
	slug: Slug;
	specs: Uuid[];
	archived?: string;
	last_heartbeat?: string;
	created: string;
	modified: string;
}

/** List of runners */
export type JsonRunners = JsonRunner[];

/** List of specs */
export type JsonSpecs = JsonSpec[];

export type Jwt = string;

export type LastFour = string;

export type LicensedPlanId = string;

/** An measure UUID or slug. */
export type MeasureResourceId = Uuid | Slug;

export type MeteredPlanId = string;

export type NonEmpty = string;

/** An organization UUID or slug. */
export type OrganizationResourceId = Uuid | Slug;

export type PollTimeout = number;

/** An project UUID or slug. */
export type ProjectResourceId = Uuid | Slug;

export type RunContext = Record<string, string>;

/** A runner UUID or slug. */
export type RunnerResourceId = Uuid | Slug;

export type Secret = string;

export type Slug = string;

/** A spec UUID or slug. */
export type SpecResourceId = Uuid | Slug;

/** A testbed UUID, slug, or name. */
export type TestbedNameId = Uuid | Slug | string;

/** An testbed UUID or slug. */
export type TestbedResourceId = Uuid | Slug;

export type UserName = string;

/** An user UUID or slug. */
export type UserResourceId = Uuid | Slug;

export type Uuid = string;

export interface JsonAccept {
	invite: Jwt;
}

export interface JsonAuthAck {
	email: Email;
}

export interface JsonUser {
	uuid: Uuid;
	name: UserName;
	slug: Slug;
	email: Email;
	admin: boolean;
	locked: boolean;
}

export interface JsonAuthUser {
	user: JsonUser;
	token: Jwt;
	creation: string;
	expiration: string;
}

export enum CardBrand {
	Amex = "amex",
	Diners = "diners",
	Discover = "discover",
	Jcb = "jcb",
	Mastercard = "mastercard",
	Unionpay = "unionpay",
	Visa = "visa",
	Unknown = "unknown",
}

export interface JsonCardDetails {
	brand: CardBrand;
	last_four: LastFour;
	exp_month: ExpirationMonth;
	exp_year: ExpirationYear;
}

export interface JsonCheckout {
	session: string;
	url: string;
}

/** Request to claim a job (runner agent endpoint) */
export interface JsonClaimJob {
	/** Maximum time to wait for a job (long-poll), in seconds (1-900) */
	poll_timeout?: PollTimeout;
}

/**
 * A claimed job returned to the runner agent.
 * 
 * Standalone type containing everything a runner needs to execute a job.
 * Config and OCI token are always present (not Optional) since
 * they are guaranteed at claim time.
 */
export interface JsonClaimedJob {
	uuid: Uuid;
	/** Full spec details (architecture, cpu, memory, etc.) */
	spec: JsonSpec;
	/** Execution config — always present for claimed jobs */
	config: JsonJobConfig;
	/** Short-lived, project-scoped OCI pull token */
	oci_token: Jwt;
	/** Maximum execution time in seconds */
	timeout: Timeout;
	/** Job creation timestamp */
	created: string;
}

export interface JsonConfirm {
	token: Jwt;
}

export interface JsonCustomer {
	uuid: Uuid;
	name: NonEmpty;
	email: Email;
}

export enum PlanLevel {
	Free = "free",
	Team = "team",
	Enterprise = "enterprise",
}

export interface JsonLicense {
	key: Jwt;
	organization: Uuid;
	level: PlanLevel;
	entitlements: Entitlements;
	issued_at: string;
	expiration: string;
	self_hosted: boolean;
}

export interface JsonLogin {
	email: Email;
	plan?: PlanLevel;
	invite?: Jwt;
	recaptcha_token?: NonEmpty;
}

export interface JsonNewCheckout {
	organization: OrganizationResourceId;
	level: PlanLevel;
	entitlements?: Entitlements;
	self_hosted?: Uuid;
}

export interface JsonNewClaim {
	empty?: undefined;
}

export enum OrganizationRole {
	/** The organization leader role. */
	Leader = "leader",
}

export interface JsonNewMember {
	/** The user name for the invitee. */
	name?: UserName;
	/**
	 * The email for the invitee.
	 * This will be used to both send the invite
	 * and to create the user account if they do not exist.
	 */
	email: Email;
	/** The organization role for the invitee. */
	role: OrganizationRole;
}

export interface JsonNewPlan {
	checkout: NonEmpty;
	level: PlanLevel;
	entitlements?: Entitlements;
	self_hosted?: Uuid;
	remote?: boolean;
}

export enum XAxis {
	DateTime = "date_time",
	Version = "version",
}

export interface JsonNewPlot {
	/**
	 * The index of the plot.
	 * Maximum index is 64.
	 */
	index?: Index;
	/**
	 * The title of the plot.
	 * Maximum length is 64 characters.
	 */
	title?: ResourceName;
	/** Display metric lower values. */
	lower_value: boolean;
	/** Display metric upper values. */
	upper_value: boolean;
	/** Display lower boundary limits. */
	lower_boundary: boolean;
	/** Display upper boundary limits. */
	upper_boundary: boolean;
	/** The x-axis to use for the plot. */
	x_axis: XAxis;
	/**
	 * The window of time for the plot, in seconds.
	 * Metrics outside of this window will be omitted.
	 */
	window: Window;
	/**
	 * The branches to include in the plot.
	 * At least one branch must be specified.
	 */
	branches: Uuid[];
	/**
	 * The testbeds to include in the plot.
	 * At least one testbed must be specified.
	 */
	testbeds: Uuid[];
	/**
	 * The benchmarks to include in the plot.
	 * At least one benchmark must be specified.
	 */
	benchmarks: Uuid[];
	/**
	 * The measures to include in the plot.
	 * At least one measure must be specified.
	 */
	measures: Uuid[];
}

export enum Visibility {
	Public = "public",
	Private = "private",
}

export interface JsonNewProject {
	/**
	 * The name of the project.
	 * Maximum length is 64 characters.
	 */
	name: ResourceName;
	/**
	 * The preferred slug for the project.
	 * If not provided, the slug will be generated from the name.
	 * If the provided or generated slug is already in use, a unique slug will be generated.
	 * Maximum length is 64 characters.
	 */
	slug?: Slug;
	/**
	 * The URL for the project.
	 * If the project is public, the URL will be accessible listed on its Perf Page.
	 */
	url?: Url;
	/**
	 * ➕ Bencher Plus: Set the visibility of the project.
	 * Creating a `private` project requires a valid Bencher Plus subscription.
	 */
	visibility?: Visibility;
}

/**
 * Job configuration for a remote runner execution.
 * 
 * Sent as part of `JsonNewRun` when the CLI `--image` flag is used.
 * The API server uses this to create a job for a bare metal runner
 * instead of expecting locally-executed benchmark results.
 */
export interface JsonNewRunJob {
	/** OCI image reference (e.g. "alpine:3.18", "ghcr.io/owner/repo:v1", "image@sha256:abc...") */
	image: string;
	/** Hardware spec slug or UUID to run on */
	spec?: SpecResourceId;
	/** Container entrypoint override (like Docker ENTRYPOINT) */
	entrypoint?: string[];
	/** Command override (like Docker CMD) */
	cmd?: string[];
	/** Environment variables passed to the container */
	env?: Record<string, string>;
	/** Maximum execution time in seconds */
	timeout?: Timeout;
	/** File paths to collect from the VM after job completion */
	file_paths?: string[];
	/** Track the build time of the benchmark command */
	build_time?: boolean;
	/** Track the file size of the output files instead of parsing their contents */
	file_size?: boolean;
	/** Number of benchmark iterations for the runner to execute */
	iter?: Iteration;
	/** Allow benchmark failure without short-circuiting iterations */
	allow_failure?: boolean;
	/** Backdate the report start time */
	backdate?: string;
}

/** Create a new runner */
export interface JsonNewRunner {
	/** The name of the runner. */
	name: ResourceName;
	/**
	 * The preferred slug for the runner.
	 * If not provided, the slug will be generated from the name.
	 */
	slug?: Slug;
}

/** Add a spec to a runner */
export interface JsonNewRunnerSpec {
	/** The UUID or slug of the spec to associate with the runner. */
	spec: SpecResourceId;
}

/** Create a new spec */
export interface JsonNewSpec {
	/** The name of the spec. */
	name: ResourceName;
	/**
	 * The preferred slug for the spec.
	 * If not provided, the slug will be generated from the name.
	 */
	slug?: Slug;
	/** CPU architecture */
	architecture: Architecture;
	/** Number of CPUs */
	cpu: number;
	/** Memory size in bytes */
	memory: number;
	/** Disk size in bytes */
	disk: number;
	/** Whether the VM has network access */
	network?: boolean;
	/** Whether this spec is the fallback spec */
	fallback?: boolean;
}

export interface JsonNewSso {
	/**
	 * The SSO domain.
	 * For example: example.com
	 */
	domain: NonEmpty;
}

export interface JsonNewToken {
	/**
	 * The name of the token.
	 * Maximum length is 64 characters.
	 */
	name: ResourceName;
	/**
	 * The time-to-live (TTL) for the token in seconds.
	 * If not provided, the token will not expire for over 128 years.
	 */
	ttl?: number;
}

export interface JsonOAuth {
	state: Jwt;
	code: Secret;
}

export interface JsonOAuthUrl {
	url: Url;
}

export interface JsonOAuthUser {
	user: JsonAuthUser;
	plan?: PlanLevel;
}

export interface JsonPerfAlert {
	uuid: Uuid;
	limit: BoundaryLimit;
	status: AlertStatus;
	modified: string;
}

export interface JsonOneMetric {
	uuid: Uuid;
	report: Uuid;
	iteration: Iteration;
	start_time: string;
	end_time: string;
	branch: JsonBranch;
	testbed: JsonTestbed;
	benchmark: JsonBenchmark;
	measure: JsonMeasure;
	metric: JsonMetric;
	threshold?: JsonThresholdModel;
	boundary?: JsonBoundary;
	alert?: JsonPerfAlert;
}

export interface JsonSso {
	uuid: Uuid;
	domain: NonEmpty;
	created: string;
}

export interface JsonOrganization {
	uuid: Uuid;
	name: ResourceName;
	slug: Slug;
	license?: Jwt;
	sso?: JsonSso[];
	created: string;
	modified: string;
	claimed?: string;
}

export interface JsonProject {
	uuid: Uuid;
	organization: Uuid;
	name: ResourceName;
	slug: Slug;
	url?: Url;
	visibility: Visibility;
	created: string;
	modified: string;
	claimed?: string;
}

export interface JsonPerfMetric {
	report: Uuid;
	iteration: Iteration;
	start_time: string;
	end_time: string;
	version: JsonVersion;
	metric: JsonMetric;
	threshold?: JsonThresholdModel;
	boundary?: JsonBoundary;
	alert?: JsonPerfAlert;
}

export interface JsonPerfMetrics {
	branch: JsonBranch;
	testbed: JsonTestbed;
	benchmark: JsonBenchmark;
	measure: JsonMeasure;
	metrics: JsonPerfMetric[];
}

export interface JsonPerf {
	project: JsonProject;
	start_time?: string;
	end_time?: string;
	results: JsonPerfMetrics[];
}

/**
 * `JsonPerfQuery` is the full, strongly typed version of `JsonPerfQueryParams`.
 * It should always be used to validate `JsonPerfQueryParams`.
 */
export interface JsonPerfQuery {
	branches: Uuid[];
	heads: Uuid[];
	testbeds: Uuid[];
	specs: Uuid[];
	benchmarks: Uuid[];
	measures: Uuid[];
	start_time?: string;
	end_time?: string;
}

export enum PlanStatus {
	Active = "active",
	Canceled = "canceled",
	Incomplete = "incomplete",
	IncompleteExpired = "incomplete_expired",
	PastDue = "past_due",
	Paused = "paused",
	Trialing = "trialing",
	Unpaid = "unpaid",
}

export interface JsonPlan {
	organization: Uuid;
	customer: JsonCustomer;
	card: JsonCardDetails;
	level: PlanLevel;
	unit_amount: number;
	current_period_start: string;
	current_period_end: string;
	status: PlanStatus;
	license?: JsonLicense;
}

export interface JsonPlot {
	uuid: Uuid;
	project: Uuid;
	title?: ResourceName;
	lower_value: boolean;
	upper_value: boolean;
	lower_boundary: boolean;
	upper_boundary: boolean;
	x_axis: XAxis;
	window: Window;
	branches: Uuid[];
	testbeds: Uuid[];
	benchmarks: Uuid[];
	measures: Uuid[];
	created: string;
	modified: string;
}

export interface JsonPubUser {
	uuid: Uuid;
	name: UserName;
	slug: Slug;
}

export enum Adapter {
	Magic = "magic",
	Json = "json",
	Rust = "rust",
	RustBench = "rust_bench",
	RustCriterion = "rust_criterion",
	RustIai = "rust_iai",
	RustGungraun = "rust_gungraun",
	Cpp = "cpp",
	CppGoogle = "cpp_google",
	CppCatch2 = "cpp_catch2",
	Go = "go",
	GoBench = "go_bench",
	Java = "java",
	JavaJmh = "java_jmh",
	CSharp = "c_sharp",
	CSharpDotNet = "c_sharp_dot_net",
	Js = "js",
	JsBenchmark = "js_benchmark",
	JsTime = "js_time",
	Python = "python",
	PythonAsv = "python_asv",
	PythonPytest = "python_pytest",
	Ruby = "ruby",
	RubyBenchmark = "ruby_benchmark",
	Shell = "shell",
	ShellHyperfine = "shell_hyperfine",
}

export interface JsonReport {
	uuid: Uuid;
	user?: JsonPubUser;
	project: JsonProject;
	branch: JsonBranch;
	testbed: JsonTestbed;
	start_time: string;
	end_time: string;
	adapter: Adapter;
	results: JsonReportResults;
	alerts: JsonReportAlerts;
	created: string;
}

/** Runner token response (returned on create or rotate) */
export interface JsonRunnerToken {
	uuid: Uuid;
	/** The runner token. Only shown once - store it securely! */
	token: Secret;
}

export interface JsonSignup {
	name: UserName;
	slug?: Slug;
	email: Email;
	plan?: PlanLevel;
	invite?: Jwt;
	claim?: Uuid;
	/** I agree to the Bencher Terms of Use (https://bencher.dev/legal/terms-of-use), Privacy Policy (https://bencher.dev/legal/privacy), and License Agreement (https://bencher.dev/legal/license) */
	i_agree: boolean;
	recaptcha_token?: NonEmpty;
}

export interface JsonToken {
	uuid: Uuid;
	user: Uuid;
	name: ResourceName;
	token: Jwt;
	creation: string;
	expiration: string;
}

export enum UpdateAlertStatus {
	/** The alert is active. */
	Active = "active",
	/** The alert has been dismissed by a user. */
	Dismissed = "dismissed",
}

export interface JsonUpdateAlert {
	/** The new status of the alert. */
	status?: UpdateAlertStatus;
}

/** Update a runner */
export interface JsonUpdateRunner {
	/** The new name for the runner. */
	name?: ResourceName;
	/** The new slug for the runner. */
	slug?: Slug;
	/** Set whether the runner is archived. */
	archived?: boolean;
}

/** Update a spec */
export interface JsonUpdateSpec {
	/** The new name for the spec. */
	name?: ResourceName;
	/** The new slug for the spec. */
	slug?: Slug;
	/** Set whether the spec is the fallback spec. */
	fallback?: boolean;
	/** Set whether the spec is archived. */
	archived?: boolean;
}

export interface JsonUpdateUser {
	/**
	 * The new name of the user.
	 * Maximum length is 64 characters.
	 * May only contain alphanumeric characters, non-leading or trailing spaces, and the following characters: , . - '
	 */
	name?: UserName;
	/**
	 * The preferred new slug for the user.
	 * Maximum length is 64 characters.
	 */
	slug?: Slug;
	/** The new email for the user. */
	email?: Email;
	/**
	 * Update whether the user is an admin.
	 * Must be an admin to update this field.
	 */
	admin?: boolean;
	/**
	 * Update whether the user is locked.
	 * Must be an admin to update this field.
	 */
	locked?: boolean;
}

export enum UsageKind {
	/** Bencher Cloud (Free) */
	CloudFree = "cloud_free",
	/** Bencher Cloud (Metered) */
	CloudMetered = "cloud_metered",
	/** Bencher Cloud (Licensed) */
	CloudLicensed = "cloud_licensed",
	/** Bencher Self-Hosted (Licensed) via Bencher Cloud */
	CloudSelfHostedLicensed = "cloud_self_hosted_licensed",
	/** Bencher Self-Hosted (Free) */
	SelfHostedFree = "self_hosted_free",
	/** Bencher Self-Hosted (Licensed) */
	SelfHostedLicensed = "self_hosted_licensed",
}

export interface JsonUsage {
	/** The organization UUID. */
	organization: Uuid;
	/** The kind of usage. */
	kind: UsageKind;
	/** The organization plan. */
	plan?: JsonPlan;
	/** The organization license. */
	license?: JsonLicense;
	/** The start time of the usage. */
	start_time: string;
	/** The end time of the usage. */
	end_time: string;
	/** The metrics usage amount. */
	usage?: number;
}

/**
 * Job priority — determines scheduling order and concurrency limits.
 * 
 * Priority tiers:
 * - Enterprise (300): Unlimited concurrent jobs
 * - Team (200): Unlimited concurrent jobs
 * - Free (100): 1 concurrent job per organization
 * - Unclaimed (0): 1 concurrent job per source IP
 */
export enum JobPriority {
	Unclaimed = "unclaimed",
	Free = "free",
	Team = "team",
	Enterprise = "enterprise",
}

export enum OrganizationPermission {
	View = "view",
	Create = "create",
	Edit = "edit",
	Delete = "delete",
	Manage = "manage",
	ViewRole = "view_role",
	CreateRole = "create_role",
	EditRole = "edit_role",
	DeleteRole = "delete_role",
}

export enum PerfQueryKey {
	Branches = "branches",
	Heads = "heads",
	Testbeds = "testbeds",
	Specs = "specs",
	Benchmarks = "benchmarks",
	Measures = "measures",
	StartTime = "start_time",
	EndTime = "end_time",
}

export enum PlotKey {
	LowerValue = "lower_value",
	UpperValue = "upper_value",
	LowerBoundary = "lower_boundary",
	UpperBoundary = "upper_boundary",
	XAxis = "x_axis",
}

export enum ProjectPermission {
	View = "view",
	Create = "create",
	Edit = "edit",
	Delete = "delete",
	Manage = "manage",
	ViewRole = "view_role",
	CreateRole = "create_role",
	EditRole = "edit_role",
	DeleteRole = "delete_role",
}

/** <https://docs.cloud.google.com/recaptcha/docs/actions-website> */
export enum RecaptchaAction {
	Signup = "signup",
	Login = "login",
}

