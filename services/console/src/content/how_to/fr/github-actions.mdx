---
title: "GitHub Actions"
description: "Utilisez Bencher dans GitHub Actions pour des tests de performance continus sur les pull requests"
heading: "Comment utiliser Bencher dans GitHub Actions"
sortOrder: 3
---

import GitHubActions1 from "../../../chunks/how_to/github-actions.1.mdx";
import GitHubActions2 from "../../../chunks/how_to/github-actions.2.mdx";
import GitHubActions3 from "../../../chunks/how_to/github-actions.3.mdx";
import GitHubActions4 from "../../../chunks/how_to/github-actions.4.mdx";
import GitHubActions5 from "../../../chunks/how_to/github-actions.5.mdx";

<GitHubActions1 />

1. Cr√©ez un fichier `workflow` pour GitHub Actions. (ex: `.github/workflows/benchmark.yml`)
2. Ex√©cutez sur les √©v√©nements `push` vers la branche `main`. Consultez la [documentation `on` de GitHub Actions](https://docs.github.com/fr/actions/using-workflows/workflow-syntax-for-github-actions#on) pour une vue d'ensemble compl√®te. Voir aussi [Pull Requests](#pull-requests) ci-dessous.
3. Cr√©ez un `job` pour GitHub Actions. (ex: `benchmark_with_bencher`)
4. Le Projet doit d√©j√† exister. D√©finissez le drapeau `--project` ou la variable d'environnement `BENCHER_PROJECT` avec le slug ou l'UUID du Projet (ex: `BENCHER_PROJECT: save-walter-white`).
5. Le jeton API doit d√©j√† exister. Ajoutez `BENCHER_API_TOKEN` en tant que secret **Repository**. (ex: `Repo -> Settings -> Secrets and variables -> Actions -> New repository secret`). D√©finissez le drapeau `--token`ou la variable d'environnement `BENCHER_API_TOKEN` avec le jeton API.  (ex: `BENCHER_API_TOKEN: ${{ secrets.BENCHER_API_TOKEN }}`)
6. Optionnel : r√©glez le drapeau `--testbed` ou la variable d'environnement `BENCHER_TESTBED` amenant au slug ou √† l'UUID de Testbed.  (ex: `BENCHER_TESTBED: ubuntu-latest`) Le Testbed **doit** d√©j√† exister. Si ce n'est pas d√©fini, le Testbed `localhost` sera utilis√©.
7. Optionnel : r√©glez le drapeau `--adapter` ou la variable d'environnement `BENCHER_ADAPTER` avec le nom de l'adaptateur d√©sir√©.  (ex: `BENCHER_ADAPTER: json`) Si ce n'est pas d√©fini, l'Adaptateur `magic` sera utilis√©. Consultez les [adaptateurs de harnais de benchmark](/docs/fr/explanation/adapters) pour une vue d'ensemble compl√®te.
8. Extraites votre code source. (ex: `uses: actions/checkout@v3`)
9. Installez le CLI de Bencher en utilisant [GitHub Action](https://github.com/marketplace/actions/bencher-cli). (ex: `uses: bencherdev/bencher@main`)
10. [Suivez vos benchmarks](/docs/fr/how-to/track-benchmarks) avec la sous-commande CLI <code><a href="/docs/fr/explanation/bencher-run">bencher run</a></code>:
    1. Optionnel : r√©glez le drapeau `--branch` ou la variable d'environnement `BENCHER_BRANCH` avec le slug ou l'UUID de la Branche. (ex: `--branch main`). La Branche **doit** d√©j√† exister. Si ce n'est pas d√©fini, la branche `main` sera utilis√©e.
    2. Param√©trez la commande pour √©chouer si une Alerte est g√©n√©r√©e. (ex: `--err`) Pour qu'une Alerte soit g√©n√©r√©e, un [Seuil](/docs/fr/explanation/thresholds) doit d√©j√† exister.
    3. Ex√©cutez vos benchmarks et g√©n√©rez un Account √† partir des r√©sultats. (ex: `"bencher mock"`)

<br/>

## Pull Requests

Pour d√©tecter la r√©gression de performance dans les Pull Requests, vous devrez ex√©cuter vos benchmarks sur les PRs.
Si vous pr√©voyez uniquement d'avoir des PRs provenant de branches au sein du **m√™me** d√©p√¥t, vous pouvez simplement modifier l'exemple ci-dessus pour √©galement ex√©cuter `on` sur les √©v√©nements `pull_request`.

> ‚ö†Ô∏è Cette solution ne fonctionne que si toutes les PRs proviennent du **m√™me** d√©p√¥t!
> Voir [Pull Requests √† partir de Forks](#pull-requests-from-forks) ci-dessous.

<GitHubActions2 />

1. Ex√©cutez sur les √©v√©nements `push` √† la branche `main` et sur les √©v√©nements `pull_request`. Il est important de limiter l'ex√©cution `on` `push` **uniquement** √† certaines branches selectionn√©es (ex: `main`) pour emp√™cher les pushes vers les branches de PR de s'ex√©cuter deux fois!
2. Au lieu d'utiliser toujours la branche `main`, utilisez les [variables d'environnement par d√©faut de GitHub Action](https://docs.github.com/fr/actions/learn-github-actions/variables#default-environment-variables) pour :
        1. Utiliser des donn√©es de branche actuelles si elles existent d√©j√†. (ex: `--if-branch --if-branch '${{ env.PR_HEAD }}'`)
        2. Cr√©er un clone des donn√©es et des seuils de la branche cible de la PR si cela existe d√©j√†. (ex: `--else-if-branch '${{ github.base_ref }}'`)
        3. Sinon, cr√©ez un clone des donn√©es et des seuils de la branche `main`. (ex: `--else-if-branch main`)
        4. Il existe plusieurs options pour d√©finir la branche du projet. Voir la [s√©lection de branche](/docs/fr/explanation/branch-selection) pour une vue d'ensemble compl√®te.
3. Param√©trez le jeton d'authentification de l'API GitHub. (ex: `--github-actions "${{ secrets.GITHUB_TOKEN }}"`). Lorsque cette option est d√©finie dans le cadre d'une pull request, alors les r√©sultats seront ajout√©s √† la pull request sous forme de commentaire. Ceci utilise [la variable d'environnement `GITHUB_TOKEN` des GitHub Actions](https://docs.github.com/fr/actions/security-guides/automatic-token-authentication).
4. Consultez la documentation [bencher run](/docs/fr/explanation/bencher-run) pour une vue d'ensemble compl√®te de toutes les fa√ßons de configurer le commentaire de pull request avec les drapeaux `--ci-*`.

## Pull Requests √† partir de Forks

Si vous pr√©voyez d'accepter les pull requests √† partir de forks, comme c'est souvent le cas dans les projets open source publics,
alors vous devrez g√©rer les choses un peu diff√©remment.
Pour des raisons de s√©curit√©, les secrets tels que votre `BENCHER_API_TOKEN` et le `GITHUB_TOKEN` ne sont pas disponibles dans GitHub Actions pour les PRs de fork.
C'est-√†-dire que si un contributeur externe ouvre une PR √† partir d'un fork, l'exemple ci-dessus ne fonctionnera pas.
Il y a trois options pour les PRs de fork :

<ul>
  <li>[Tester la PR de Fork √† partir de la Branche Cible](#benchmark-fork-pr-from-target-branch)</li>
  <li>[Tester la PR de Fork √† partir de la Branche Cible avec R√©viseurs N√©cessaires](#benchmark-fork-pr-from-target-branch-with-required-reviewers)</li>
  <li>[Tester la PR de Fork et T√©l√©charger √† partir de la Branche par D√©faut](#benchmark-fork-pr-and-upload-from-default-branch)</li>
</ul>

### Tester la PR de Fork √† partir de la Branche Cible

<GitHubActions3 />

1. Ex√©cutez sur les √©v√©nements `push` √† la branche `main` et [sur les √©v√©nements `pull_request_target`](https://docs.github.com/fr/actions/using-workflows/events-that-trigger-workflows#pull_request_target).
2. Cr√©ez un `job` qui s'ex√©cute uniquement pour les √©v√©nements `push` √† la branche `main`. √Ä part la condition `if`, ce job est presque identique √† l'exemple original ci-dessus.
3. Cr√©ez un `job` qui s'ex√©cute uniquement pour les √©v√©nements `pull_request_target`.
   1. Extraites la branche de pull request.
   2. Transmettez directement tous les secrets. Utilisez `--token "${{ secrets.BENCHER_API_TOKEN }}"` au lieu de la variable d'environnement `BENCHER_API_TOKEN`.
   3. Ex√©cutez et suivez vos benchmarks de pull request avec `bencher run`.

Cette configuration fonctionne parce que `pull_request_target` s'ex√©cute dans le contexte de la branche cible de la pull request,
o√π les secrets tels que votre `BENCHER_API_TOKEN` et le `GITHUB_TOKEN` sont disponibles.
Par cons√©quent, ce workflow ne s'ex√©cutera que s'il existe sur la branche _cible_.
√âvitez de d√©finir des secrets comme des variables d'environnement, comme `BENCHER_API_TOKEN`.
Au lieu de cela, passez explicitement le jeton API √† `bencher run`. (ex: `--token "${{ secrets.BENCHER_API_TOKEN }}"`)
Voir ce [document du GitHub Security Lab](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)
et [cet article de blog](https://nathandavison.com/blog/github-actions-and-the-threat-of-malicious-pull-requests)
sur la pr√©vention des requ√™tes pwn pour une vue d'ensemble compl√®te.

### Tester la PR de Fork √† partir de la Branche Cible avec R√©viseurs N√©cessaires

<GitHubActions4 />

Cette configuration est exactement la m√™me que [Tester la PR de Fork √† partir de la Branche Cible](#benchmark-fork-pr-from-target-branch)
avec l'exigence suppl√©mentaire de l'approbation d'un R√©viseur N√©cessaire avant chaque ex√©cution de pull request de fork.
Les pull requests du m√™me d√©p√¥t ne n√©cessitent pas d'approbation.
Pour configurer cela, vous devez [cr√©er deux Environnements d'Action GitHub](https://docs.github.com/fr/actions/deployment/targeting-different-environments/using-environments-for-deployment#using-an-environment)
(ex: `Repo -> Settings -> Environments -> New environment`).
L'environnement `internal` ne doit avoir aucune `R√®gles de protection de d√©ploiement`.
Cependant, l'environnement `external` doit avoir des `R√©viseurs n√©cessaires` d√©finis comme ceux de confiance pour r√©viser les PRs de fork avant le benchmarking.

### Tester la PR de Fork et T√©l√©charger √† partir de la Branche par D√©faut

<GitHubActions5 />

1. Cr√©ez un fichier de workflow `Ex√©cutez et Cachez les Benchmarks`.
1. Ex√©cutez vos benchmarks sur les √©v√©nements `pull_request`.
1. Sauvegardez les r√©sultats des benchmarks dans un fichier et t√©l√©chargez-les comme un artefact.
1. T√©l√©chargez l'√©v√©nement `pull_request` comme un artefact.
1. Cr√©ez un second fichier de workflow, `Suivez les Benchmarks`.
1. Encha√Ænez `Suivez les Benchmarks` √† `Ex√©cutez et Cachez les Benchmarks` avec [l'√©v√©nement `workflow_run`](https://docs.github.com/fr/actions/using-workflows/events-that-trigger-workflows#workflow_run).
1. Extrayez les donn√©es n√©cessaires de l'√©v√©nement `pull_request` en cache.
1. Suivez les r√©sultats de benchmark en cache avec `bencher run`.
1. Cr√©ez un troisi√®me fichier de workflow et utilisez l'exemple initial ci-dessus pour ex√©cuter sur les √©v√©nements `push` √† la branche `main`.

Cette configuration fonctionne parce que `workflow_run` s'ex√©cute dans le contexte de la branche par d√©faut du d√©p√¥t,
o√π les secrets tels que votre `BENCHER_API_TOKEN` et le `GITHUB_TOKEN` sont disponibles.
Par cons√©quent, ces workflows ne s'ex√©cuteront que s'ils existent sur la branche _par d√©faut_.
Voir [l'utilisation de donn√©es provenant du workflow d√©clencheur](https://docs.github.com/fr/actions/using-workflows/events-that-trigger-workflows#using-data-from-the-triggering-workflow) pour une vue d'ensemble compl√®te.
Le num√©ro de pull request, la branche de t√™te et la branche de base utilis√©s dans le workflow initial doivent √™tre explicitement transmis car ils ne sont pas disponibles √† l'int√©rieur de `workflow_run`.

Il est √©galement _tr√®s_ important d'entourer le nom de la branche PR (head ref) de **simples** apostrophes. (ex : `--if-branch '${{ env.PR_HEAD }}'`) Sans quoi, un attaquant pourrait cr√©er une branche malicieusement nomm√©e qui effectue une injection de commande. Consultez ce [compte-rendu du GitHub Security Lab](https://securitylab.github.com/research/github-actions-untrusted-input/) sur la pr√©vention des requ√™tes pwn provenant d'entr√©es non fiables pour une vue d'ensemble compl√®te.

<br/>
<br/>

> üê∞ F√©licitations ! Vous avez appris √† utiliser Bencher dans GitHub Actions ! üéâ

<br/>

<h2><a href="/docs/fr/explanation/benchmarking">Continuez : Vue d'ensemble du Benchmarking ‚û°</a></h2>
