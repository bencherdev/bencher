import PlayGameRsBenchPlayGame from "../play-game-rs-bench-play-game.mdx";

### Crear una Funci칩n de Benchmark

Ahora, podemos crear una funci칩n de benchmark que juegue el juego FizzBuzzFibonacci:

<PlayGameRsBenchPlayGame />

L칤nea por l칤nea:
- Crear una funci칩n de benchmark que coincida con la firma utilizada en `CustomBenchmark`.
- Crear un `dhat::Profiler` en modo de prueba,
  para recopilar resultados de nuestro `dhat::Alloc` asignador global personalizado.
- Ejecutar nuestra funci칩n `play_game` dentro de una "caja negra" para que el compilador no optimice nuestro c칩digo.
- Iterar de `1` a `100` inclusivamente.
- Para cada n칰mero, llamar a `play_game`, con `print` establecido en `false`.
- Devolver nuestras estad칤sticas de asignaci칩n de heap como `dhat::HeapStats`.

> 游냟 Establecemos `print` en `false` para la funci칩n `play_game`.
> Esto evita que `play_game` imprima en la salida est치ndar.
> Parametrizar las funciones de tu librer칤a de esta manera
> puede hacerlas m치s adecuadas para el benchmarking.
> Sin embargo, esto significa que puede que no estemos evaluando la librer칤a
> de la misma manera que se usa en producci칩n.
>
> En este caso, debemos preguntarnos:
> 1. 쯅os importan los recursos que se necesitan para imprimir en la salida est치ndar?
> 2. 쮼s la impresi칩n en la salida est치ndar una posible fuente de ruido?
>
> Para nuestro ejemplo, hemos decidido:
> 1. No, no nos importa imprimir en la salida est치ndar.
> 2. S칤, es una fuente de ruido muy probable.
>
> Por lo tanto, hemos omitido la impresi칩n en la salida est치ndar como parte de este benchmark.
> El benchmarking es dif칤cil y, a menudo, no hay una respuesta correcta a preguntas como estas.
> [Depende][changelog it depends].

[changelog it depends]: https://changelog.com/topic/itdepends