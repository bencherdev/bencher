---
title: "Iai"
description: "Eine Schritt-f√ºr-Schritt-Anleitung zum Benchmarking von Rust-Code mit Iai"
heading: "Wie man Rust-Code mit Iai benchmarkt"
published: "2024-02-13T06:50:00Z"
sortOrder: 3
---

import Benchmarking from "../../../chunks/benchmarking/de/benchmarking.mdx";
import FizzBuzzRules from "../../../chunks/benchmarking/de/fizz-buzz-rules.mdx";
import FizzBuzzRust from "../../../chunks/rust/de/fizz-buzz-rust.mdx";
import StepByStepRust from "../../../chunks/rust/de/step-by-step-rust.mdx";
import MicroVsMacro from "../../../chunks/benchmarking/de/micro-vs-macro.mdx";
import BenchmarkingRust from "../../../chunks/rust/de/benchmarking-rust.mdx";
import FizzBuzzRefactor from "../../../chunks/rust/criterion/de/fizz-buzz-refactor.mdx";
import GameBenchesTree from "../../../chunks/rust/criterion/game-benches-tree.mdx";
import FizzBuzzRefactorBenchesCode from "../../../chunks/rust/iai/fizz-buzz-refactor-benches-code.mdx";
import GameCargoToml from "../../../chunks/rust/iai/game-cargo-toml.mdx";
import BenchPlayGameOutput from "../../../chunks/rust/iai/bench-play-game-output.mdx";
import FizzBuzzFibonacciRust from "../../../chunks/rust/de/fizz-buzz-fibonacci-rust.mdx";
import PlayGameRustCode from "../../../chunks/rust/criterion/play-game-rust-code.mdx";
import BenchPlayGameFibonacciOutput from "../../../chunks/rust/iai/bench-play-game-fibonacci-output.mdx";
import FizzBuzzFibonacciOpenRust from "../../../chunks/rust/de/fizz-buzz-fibonacci-open-rust.mdx";
import FizzBuzzFibonacciOpenRustCode from "../../../chunks/rust/criterion/fizz-buzz-fibonacci-open-rust-code.mdx";
import TheEnd from "../../../chunks/benchmarking/de/the-end.mdx";
import OnFire from "../../../chunks/benchmarking/de/on-fire.mdx";
import BenchPlayGameOnFireCode from "../../../chunks/rust/iai/bench-play-game-on-fire-code.mdx";
import BenchPlayGameOnFireOutputStart from "../../../chunks/rust/iai/bench-play-game-on-fire-output-start.mdx";
import BenchPlayGameOnFireOutput from "../../../chunks/rust/iai/bench-play-game-on-fire-output.mdx";
import FizzBuzzFibonacciFixRust from "../../../chunks/rust/de/fizz-buzz-fibonacci-fix-rust.mdx";
import BenchPlayGameFixOutput from "../../../chunks/rust/iai/bench-play-game-fix-output.mdx";
import CatchInCi from "../../../chunks/benchmarking/de/catch-in-ci.mdx";
import CatchInCiOutput from "../../../chunks/rust/iai/catch-in-ci-output.mdx";
import CatchInCiPlot from "../../../chunks/benchmarking/de/catch-in-ci-plot.mdx";
import CatchInCiPlotRustBench from "../../../chunks/rust/catch-in-ci-plot-rust-bench.mdx";
import BencherFooter from "../../../chunks/learn/de/bencher-footer.mdx";

<Benchmarking />

<FizzBuzzRust />

<StepByStepRust />

<MicroVsMacro />

<BenchmarkingRust />

Alle drei werden [unterst√ºtzt von Bencher](/de/docs/explanation/adapters/). Warum also Iai w√§hlen?
Iai verwendet Anweisungsz√§hler statt Echtzeit.
Das macht es ideal f√ºr [dauerndes Benchmarking](/de/docs/explanation/continuous-benchmarking/), also Benchmarking in CI.
Ich w√ºrde vorschlagen, Iai f√ºr dauerndes Benchmarking zu verwenden, besonders wenn Sie gemeinsam genutzte Runner verwenden.
Es ist wichtig zu verstehen, dass Iai nur ein Proxy f√ºr das misst, was Sie wirklich interessiert.
Bedeutet der Wechsel von 1.000 Anweisungen auf 2.000 Anweisungen eine Verdoppelung der Latenz Ihrer Anwendung?
Vielleicht ja, vielleicht nein.
Aus diesem Grund kann es n√ºtzlich sein, auch Echtzeit-basierte Benchmarks parallel zu Anweisungsz√§hler-basierten Benchmarks durchzuf√ºhren.

> üê∞ Iai wurde [seit √ºber 3 Jahren nicht mehr aktualisiert](https://github.com/bheisler/iai/commits/main/). Daher k√∂nnten Sie in Betracht ziehen, [Iai-Callgrind](/de/docs/explanation/adapters/#-rust-iai-callgrind) zu verwenden.

## Install Valgrind

Iai verwendet ein Tool namens [Valgrind](https://valgrind.org/) zur Erfassung von Anweisungsz√§hlern.
Valgrind unterst√ºtzt Linux, Solaris, FreeBSD und MacOS.
Die Unterst√ºtzung von MacOS ist jedoch auf x86_64-Prozessoren beschr√§nkt, da [arm64-Prozessoren (M1, M2 usw.) noch nicht unterst√ºtzt werden](https://github.com/LouisBrunner/valgrind-macos/issues/56).

Auf Debian laufen: `sudo apt-get install valgrind`

Auf MacOS (x86_64/Intel-Chip only): `brew install valgrind`

<FizzBuzzRefactor />

## Benchmarking von FizzBuzz

Um unseren Code zu benchmarken, ben√∂tigen wir ein `benches` Verzeichnis und f√ºgen eine Datei hinzu, um unsere Benchmarks zu enthalten, `play_game.rs`:

<GameBenchesTree />

F√ºgen Sie in `play_game.rs` den folgenden Code hinzu:

<FizzBuzzRefactorBenchesCode />

- Importieren Sie die Funktion `play_game` aus unserer `game` crate.
- Erstellen Sie eine Funktion namens `bench_play_game`.
- F√ºhren Sie unser Macro-Benchmark in einer "Black Box" aus, damit der Compiler unseren Code nicht optimiert.
- Z√§hlen Sie von `1` bis `100` einschlie√ülich.
- Rufen Sie f√ºr jede Zahl `play_game` auf, mit `print` auf `false` gesetzt.

Jetzt m√ºssen wir das `game` crate konfigurieren, um unsere Benchmarks auszuf√ºhren.

F√ºgen Sie folgendes am _Ende_ Ihrer `Cargo.toml` Datei hinzu:

<GameCargoToml />

- `iai`: F√ºgen Sie `iai` als Entwicklungsabh√§ngigkeit hinzu, da wir es nur f√ºr Performance-Tests verwenden.
- `bench`: Registrieren Sie `play_game` als Benchmark und stellen Sie `harness` auf `false`, da wir Iai als unser Benchmarking-Gestell verwenden.

Jetzt sind wir bereit, unseren Code zu benchmarken, laufen Sie `cargo bench`:

<BenchPlayGameOutput />

> üê∞ Salat R√ºbe die R√ºbe! Wir haben unsere ersten Benchmark-Messwerte!

Endlich k√∂nnen wir unsere m√ºden Entwicklerk√∂pfe zur Ruhe legen...
Nur ein Scherz, unsere Benutzer wollen ein neues Feature!

<FizzBuzzFibonacciRust>
  <PlayGameRustCode />
</FizzBuzzFibonacciRust>

## Benchmarking von FizzBuzzFibonacci

Jetzt k√∂nnen wir unser Benchmark erneut ausf√ºhren:

<BenchPlayGameFibonacciOutput />

Oh, toll! Iai sagt uns, dass der Unterschied zwischen den gesch√§tzten Zyklen unserer FizzBuzz und FizzBuzzFibonacci-Spiele `+522,6091%` betr√§gt.
Ihre Zahlen werden ein wenig anders als meine sein.
Der Unterschied zwischen den beiden Spielen liegt jedoch wahrscheinlich im Bereich von `5x`.
Das scheint mir gut zu sein! Vor allem f√ºr die Hinzuf√ºgung eines so ausgefallenen Features wie _Fibonacci_ zu unserem Spiel.
Die Kinder werden es lieben!

<FizzBuzzFibonacciOpenRust>
  <FizzBuzzFibonacciOpenRustCode />
</FizzBuzzFibonacciOpenRust>

<TheEnd />

<br />

<OnFire />

<BenchPlayGameOnFireCode />

- Ein Mikro-Benchmark `bench_play_game_100` zum Spielen des Spiels mit der Zahl einhundert (`100`)
- Ein Mikro-Benchmark `bench_play_game_1_000_000` zum Spielen des Spiels mit der Zahl eine Million (`1_000_000`)

Als ich es laufen lie√ü, bekam ich dies:

<BenchPlayGameOnFireOutputStart />

Warten Sie darauf... warten Sie darauf...

<BenchPlayGameOnFireOutput />

Was?! `6,685 gesch√§tzte Zyklen` x `1,000` sollten `6,685,000 gesch√§tzte Zyklen` sein, nicht `155,109,206 gesch√§tzte Zyklen` ü§Ø
Obwohl ich meinen Fibonacci-Sequenz-Code funktional korrekt bekommen habe, muss ich irgendwo einen Leistungsfehler drin haben.

<FizzBuzzFibonacciFixRust />

Jetzt lassen Sie uns diese Benchmarks erneut laufen und sehen, wie es uns ergangen ist:

<BenchPlayGameFixOutput />

Oh, wow! Unser Benchmark `bench_play_game` ist wieder etwa da, wo es f√ºr den originalen FizzBuzz war.
Ich w√ºnschte, ich k√∂nnte mich genau an diesen Score erinnern. Es sind jedoch drei Wochen vergangen.
Meine Terminalhistorie reicht nicht so weit zur√ºck.
Und Iai vergleicht nur mit dem neuesten Resultat.
Aber ich denke, es ist nahe dran!

Der Benchmark `bench_play_game_100` ist fast 10x down, `-87,22513%`.
Und der Benchmark `bench_play_game_1_000_000` ist mehr als 10,000x down! Von `155,109,206 gesch√§tzten Zyklen` auf `950 gesch√§tzte` gesch√§tzte Zyklen!
Das ist `-99,99939%`!

> üê∞ Hey, zumindest haben wir diesen Performance-Bug erwischt, bevor er es bis zur Produktion geschafft hat... oh, richtig. Leider nicht...

<CatchInCi />

<CatchInCiOutput />

<CatchInCiPlot />

<CatchInCiPlotRustBench title="Wie man Rust mit Iai benchmarkt" />

<BencherFooter />
