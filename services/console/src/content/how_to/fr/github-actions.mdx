---
title: "GitHub Actions"
description: "Utilisez Bencher dans GitHub Actions pour le benchmarking continu sur les demandes de fusion (pull requests)"
heading: "Comment utiliser Bencher dans GitHub Actions"
sortOrder: 3
---

import GitHubActions1 from "../../../chunks/how_to/github-actions.1.mdx";
import GitHubActions2 from "../../../chunks/how_to/github-actions.2.mdx";
import GitHubActions3 from "../../../chunks/how_to/github-actions.3.mdx";
import GitHubActions4 from "../../../chunks/how_to/github-actions.4.mdx";
import GitHubActions5 from "../../../chunks/how_to/github-actions.5.mdx";

<GitHubActions1 />

1. Cr√©ez un fichier `workflow` GitHub Actions. (ex: `.github/workflows/benchmarks.yml`)
2. Ex√©cutez lors d'√©v√©nements `push` vers la branche `main`. R√©f√©rez-vous √† la [documentation GitHub Actions `on`](https://docs.github.com/fr/actions/using-workflows/workflow-syntax-for-github-actions#on) pour un aper√ßu complet. Voir aussi [Demandes de fusion](#demandes-de-fusion) ci-dessous.
3. Cr√©ez une `job` GitHub Actions. (ex: `benchmark_with_bencher`)
4. Le projet doit d√©j√† exister. D√©finissez l'option `--project` ou la variable d'environnement `BENCHER_PROJECT` pour l'identifiant court ou l'UUID du projet (ex: `BENCHER_PROJECT: save-walter-white`).
6. Facultatif: Utilisez l'option `--testbed` ou la variable d'environnement `BENCHER_TESTBED` pour l'identifiant court ou l'UUID du banc de test. (ex: `BENCHER_TESTBED: ubuntu-latest`) Le banc de test **doit** d√©j√† exister. Si cela n'est pas d√©fini, alors le banc de test `localhost` sera utilis√©.
7. Facultatif: D√©finissez l'option `--adapter` ou la variable d'environnement `BENCHER_ADAPTER` pour le nom de l'adaptateur d√©sir√©. (ex: `BENCHER_ADAPTER: json`) Si cela n'est pas d√©fini, alors l'adaptateur `magic` sera utilis√©. Voir [adaptateurs de banc de test](/docs/fr/explanation/adapters) pour un aper√ßu complet.
8. Enregistrez votre code source. (ex: `uses: actions/checkout@v3`)
9. Installez le CLI Bencher √† l'aide du [GitHub Action](https://github.com/marketplace/actions/bencher-cli). (ex: `uses: bencherdev/bencher@main`)
10. [Suivez vos benchmarks](/docs/fr/how-to/track-benchmarks) avec la sous-commande CLI <code><a href="/docs/fr/explanation/bencher-run">bencher run</a></code>:
    1. Facultatif: D√©finissez l'option `--branch` ou la variable d'environnement `BENCHER_BRANCH` pour l'identifiant court ou l'UUID de la branche. (ex: `--branch main`) La branche **doit** d√©j√† exister. Si cela n'est pas d√©fini, alors la branche `main` sera utilis√©e.
    2. Le token d'API doit d√©j√† exister. Ajoutez `BENCHER_API_TOKEN` en tant que secret de **d√©p√¥t**. (ex: `D√©p√¥t -> Settings -> Secrets and variables -> Actions -> New repository secret`) D√©finissez l'option `--token` ou la variable d'environnement `BENCHER_API_TOKEN` pour le token d'API. (ex: `--token ${{ secrets.BENCHER_API_TOKEN }}`)
    3. Configurez la commande pour √©chouer si une alerte est g√©n√©r√©e. (ex: `--err`) Pour qu'une alerte soit g√©n√©r√©e, un [Seuil](/docs/fr/explanation/thresholds) doit d√©j√† exister.
    4. Ex√©cutez vos benchmarks et g√©n√©rez un rapport √† partir des r√©sultats. (ex: `"bencher mock"`)

<br/>

## Demandes de Fusion

Pour identifier les r√©gressions de performance dans les demandes de fusion (Pull Requests), vous devez ex√©cuter vos benchmarks sur ces demandes.
Si vous ne vous attendez qu'√† n'avoir des demandes de fusion que provenant de branches se trouvent dans le **m√™me** d√©p√¥t, vous pouvez simplement modifier l'exemple ci-dessus pour ex√©cuter √©galement `on` lors d'√©v√©nements `pull_request`.

> ‚ö†Ô∏è Cette solution fonctionne uniquement si toutes les demandes de fusion sont issues du **m√™me** d√©p√¥t!
> Voir [Demandes de fusion √† partir de Forks](#demandes-de-fusion-a-partir-de-forks) ci-dessous.

<GitHubActions2 />

1. Cr√©ez un fichier `workflow` pour GitHub Actions. (ex : `.github/workflows/pr_benchmarks.yml`)
2. Ex√©cutez lors des √©v√©nements `pull_request` si et seulement si la pull request provient du m√™me d√©p√¥t. Pour g√©rer les Pull Requests depuis des Forks, voir [Pull Requests de Forks](#pull-requests-de-forks) ci-dessous.
3. [S√©lectionnez la branche](http://localhost:3000/docs/fr/explanation/branch-selection) √† utiliser :
        1. Utilisez les donn√©es de branche actuelle si elles existent d√©j√†. (ex : `--if-branch "$GITHUB_REF_NAME"`)
        2. Cr√©ez un clone des donn√©es et des seuils de la branche cible de la PR s'ils existent d√©j√†. (ex : `--else-if-branch "$GITHUB_BASE_REF"`)
        3. Sinon, cr√©ez un clone des donn√©es et des seuils de la branche `main`. (ex : `--else-if-branch main`)
4. D√©finissez le jeton d'authentification de l'API GitHub. (ex : `--github-actions "${{ secrets.GITHUB_TOKEN }}"`) Lorsque cette option est d√©finie dans le cadre d'une pull request, les r√©sultats seront ajout√©s √† la pull request sous forme de commentaire. Cela utilise [la variable d'environnement `GITHUB_TOKEN` des GitHub Actions](https://docs.github.com/fr/actions/security-guides/automatic-token-authentication).
5. Consultez la documentation [bencher run](/docs/fr/explanation/bencher-run) pour un aper√ßu complet de toutes les fa√ßons de configurer le commentaire de la pull request avec les drapeaux `--ci-*`.
6. (Non montr√©) Cr√©ez un second fichier `workflow` pour les GitHub Actions et utilisez l'exemple initial ci-dessus pour ex√©cuter lors des √©v√©nements `push` vers la branche `main`. (ex : `.github/workflows/benchmarks.yml`)

## Demandes de Fusion √† partir de Forks

Si vous pr√©voyez d'accepter des demandes de fusion provenant de forks, comme cela est souvent le cas dans les projets open source publics,
alors vous devrez g√©rer les choses un peu diff√©remment.
Pour des raisons de s√©curit√©, des secrets tels que votre `BENCHER_API_TOKEN` et le `GITHUB_TOKEN` ne sont pas disponibles dans GitHub Actions pour les demandes de fusion de forks.
C'est-√†-dire que si un contributeur externe ouvre une demande de fusion √† partir d'un fork, l'exemple ci-dessus ne fonctionnera pas.
Il existe deux options pour les demandes de fusion provenant de forks :

<ul>
  <li>[Evaluer la demande de fusion √† partir de la branche cible avec des examinateurs requis](#evaluer-la-demande-de-fusion-a-partir-de-la-branche-cible-avec-des-examinateurs-requis)</li>
  <li>[Evaluer la demande de fusion et charger depuis la branche par d√©faut](#evaluer-la-demande-de-fusion-et-charger-depuis-la-branche-par-defaut)</li>
</ul>

### Evaluer la demande de fusion √† partir de la branche cible avec des examinateurs requis

> ‚ö†Ô∏è Il est **tr√®s**, **tr√®s** important d'examiner minutieusement toute PR de bifurcation avant de l'approuver!
> Si vous ne le faites pas, cela pourrait entra√Æner une demande de pwn !
>
> Si vous pr√©f√©rez ne pas avoir cela sur la conscience, voir [Benchmark de PR de bifurcation et Upload √† partir de la branche par d√©faut](#benchmark-de-pr-de-bifurcation-et-upload-a-partir-de-la-branche-par-defaut) ci-dessous.

<GitHubActions3 />

1. Cr√©ez un fichier `workflow` GitHub Actions. (ex: `.github/workflows/pr_benchmarks.yml`)
2. Ex√©cutez [des √©v√©nements `pull_request_target`](https://docs.github.com/fr/actions/using-workflows/events-that-trigger-workflows#pull_request_target).
3. Cr√©ez une `job` nomm√©e `fork_pr_requires_review` qui n√©cessite l'approbation d'un examinateur requis avant chaque ex√©cution de demande de fusion de fork (`external`).
4. Cr√©ez une troisi√®me `job` qui d√©pend de `fork_pr_requires_review`.
   1. Enregistrez la branche de la demande de fusion mais ne conservez pas les identifiants git. (ex: `persist-credentials: false`)
   2. Utilisez des guillemets simples autour de toutes les entr√©es non fiables. (ex: `--if-branch '${{ github.head_ref }}'`)
   3. Passez tous les secrets directement. (ex: `--token "${{ secrets.BENCHER_API_TOKEN }}"`)
   4. Ex√©cutez et suivez vos benchmarks de demandes de fusion avec `bencher run`.
5. (Non montr√©) Cr√©ez un deuxi√®me fichier `workflow` GitHub Actions et utilisez l'exemple initial ci-dessus pour ex√©cuter lors d'√©v√©nements `push` vers la branche `main`. (ex: `.github/workflows/benchmarks.yml`)

Cet arrangement fonctionne parce que `pull_request_target` s'ex√©cute dans le contexte de la branche cible de la demande de fusion,
o√π des secrets tels que votre `BENCHER_API_TOKEN` et le `GITHUB_TOKEN` sont disponibles.
Par cons√©quent, ce workflow s'ex√©cutera uniquement s'il existe sur la branche _cible_.

Pour configurer cela, vous devez [cr√©er deux Environnements d'Action GitHub](https://docs.github.com/fr/actions/deployment/targeting-different-environments/using-environments-for-deployment#using-an-environment)
(ex: `D√©p√¥t -> Settings -> Environments -> New environment`).
L'environnement `internal` ne doit pas avoir de `R√®gles de protection du d√©ploiement`.
Cependant, l'environnement `external` doit avoir des `Examinateurs requis` d√©finis pour ceux de confiance pour examiner les demandes de fusion de fork avant le benchmarking.

Il est tr√®s important d'entourer le nom de la branche de la demande de fusion (r√©f√©rence de t√™te) de guillemets **simples**. (ex: `--if-branch '${{ github.head_ref }}'`) Sinon, un attaquant pourrait cr√©er une branche malicieusement nomm√©e qui effectue une injection de commandes. Voir cette [√©tude du GitHub Security Lab](https://securitylab.github.com/research/github-actions-untrusted-input/) sur la pr√©vention des requ√™tes malveillantes provenant d'entr√©es non fiables pour un aper√ßu complet.

√âvitez de d√©finir des secrets en tant que variables d'environnement, tels que `GITHUB_TOKEN` et `BENCHER_API_TOKEN`.
Passez plut√¥t explicitement les secrets √† `bencher run`. (ex: `--token "${{ secrets.BENCHER_API_TOKEN }}"`)
Consultez cette [√©tude du GitHub Security Lab](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)
et [ce billet de blog](https://nathandavison.com/blog/github-actions-and-the-threat-of-malicious-pull-requests)
sur la pr√©vention des requ√™tes malveillantes pour un aper√ßu complet.

### Evaluer la demande de fusion et charger depuis la branche par d√©faut

<GitHubActions4 />

1. Cr√©ez un fichier de workflow `Run and Cache Benchmarks`. (ex: `.github/workflows/pr_benchmarks.yml`)
2. Ex√©cutez tous les jobs du workflow lors d'√©v√©nements `pull_request`.
3. Ex√©cutez les benchmarks et enregistrez les r√©sultats dans un fichier. (ex: `benchmark_results.json`)
4. T√©l√©chargez le fichier de r√©sultats de benchmarks en tant qu'artefact.
5. T√©l√©chargez l'objet d'√©v√©nement `pull_request` en tant qu'artefact.

<GitHubActions5 />

1. Cr√©ez un second fichier de workflow, `Track Benchmarks`. (ex: `.github/workflows/track_benchmarks.yml`)
2. Cha√Æne `Track Benchmarks` √† `Run and Cache Benchmarks` avec [l'√©v√©nement `workflow_run`](https://docs.github.com/fr/actions/using-workflows/events-that-trigger-workflows#workflow_run).
3. T√©l√©chargez les r√©sultats de benchmarks en cache et l'√©v√©nement `pull_request`.
4. Extrayez les r√©sultats de benchmarks en cache et l'√©v√©nement `pull_request`.
5. Exportez les donn√©es n√©cessaires de l'√©v√©nement `pull_request` en tant que variables d'environnement.
6. Suivez les r√©sultats de benchmarks en cache avec `bencher run` :
    1. Utilisez des guillemets simples autour de toutes les entr√©es non fiables. (ex: `--if-branch '${{ env.PR_HEAD }}'`)
    2. Passez explicitement le num√©ro de la demande de fusion. (ex: `--ci-number '${{ env.PR_NUMBER }}'`)
    3. Passez le chemin de fichier vers le fichier de r√©sultats de benchmarks. (ex: `--file "$BENCHMARK_RESULTS"`)
7. (Non montr√©) Cr√©ez un troisi√®me fichier de workflow GitHub Actions et utilisez l'exemple initial ci-dessus pour ex√©cuter lors d'√©v√©nements `push` vers la branche `main`. (ex: `.github/workflows/benchmarks.yml`)

Cet arrangement fonctionne parce que `workflow_run` s'ex√©cute dans le contexte de la branche par d√©faut du d√©p√¥t,
o√π des secrets tels que votre `BENCHER_API_TOKEN` et le `GITHUB_TOKEN` sont disponibles.
Par cons√©quent, ces workflows s'ex√©cuteront uniquement s'ils existent sur la branche _par d√©faut_.
Voir [utiliser des donn√©es du workflow d√©clencheur](https://docs.github.com/fr/actions/using-workflows/events-that-trigger-workflows#using-data-from-the-triggering-workflow) pour un aper√ßu complet.

Il est tr√®s important d'entourer le nom de la branche de la demande de fusion (r√©f√©rence de t√™te) de guillemets **simples**. (ex: `--if-branch '${{ env.PR_HEAD }}'`) Sinon, un attaquant pourrait cr√©er une branche malicieusement nomm√©e qui effectue une injection de commandes. Voir cette [√©tude du GitHub Security Lab](https://securitylab.github.com/research/github-actions-untrusted-input/) sur la pr√©vention des requ√™tes malveillantes provenant d'entr√©es non fiables pour un aper√ßu complet.

√âvitez de d√©finir des secrets en tant que variables d'environnement dans le fichier de workflow `Run and Cache Benchmarks`.
Consultez cette [√©tude du GitHub Security Lab](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)
et [ce billet de blog](https://nathandavison.com/blog/github-actions-and-the-threat-of-malicious-pull-requests)
sur la pr√©vention des requ√™tes malveillantes pour un aper√ßu complet.

<br/>
<br/>

> üê∞ F√©licitations! Vous avez appris comment utiliser Bencher dans GitHub Actions! üéâ

<br/>

<h2><a href="/docs/fr/explanation/benchmarking">Continuer: Aper√ßu du Benchmarking ‚û°</a></h2>
