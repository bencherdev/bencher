---
title: "GitHub Actions"
description: "Usa Bencher en GitHub Actions para el benchmarking continuo en pull requests"
heading: "C√≥mo usar Bencher en GitHub Actions"
sortOrder: 3
---

import GitHubActions1 from "../../../chunks/how_to/github-actions.1.mdx";
import GitHubActions2 from "../../../chunks/how_to/github-actions.2.mdx";
import GitHubActions3 from "../../../chunks/how_to/github-actions.3.mdx";
import GitHubActions4 from "../../../chunks/how_to/github-actions.4.mdx";
import GitHubActions5 from "../../../chunks/how_to/github-actions.5.mdx";

<GitHubActions1 />

1. Crea un archivo `workflow` de GitHub Actions. (ej: `.github/workflows/benchmarks.yml`)
2. Ejecutar en eventos `push` a la rama `main`. Consulte la [documentaci√≥n `on` de GitHub Actions](https://docs.github.com/es/actions/using-workflows/workflow-syntax-for-github-actions#on) para obtener una visi√≥n completa. Tambi√©n consulte [Pull Requests](#pull-requests) a continuaci√≥n.
3. Crea un `job` de GitHub Actions. (ej: `benchmark_with_bencher`)
4. El proyecto debe existir previamente. Establece la bandera `--project` o la variable de entorno `BENCHER_PROJECT` a la representaci√≥n √∫nica o UUID del proyecto (ej: `BENCHER_PROJECT: save-walter-white`).
5. La ficha API ya debe existir. A√±ade `BENCHER_API_TOKEN` como un secreto del **repositorio**. (ej: `Repo -> Settings -> Secrets and variables -> Actions -> New repository secret`) Establece la bandera `--token` o la variable de entorno `BENCHER_API_TOKEN` a la ficha API. (ej: `BENCHER_API_TOKEN: ${{ secrets.BENCHER_API_TOKEN }}`)
6. Opcional: Configura la bandera `--testbed` o la variable de entorno `BENCHER_TESTBED` a la representaci√≥n √∫nica o UUID de Testbed. (ej: `BENCHER_TESTBED: ubuntu-latest`) El Testbed **debe** existir previamente. Si no se establece esto, entonces se utilizar√° el Testbed `localhost`.
7. Opcional: Configura la bandera `--adapter` o la variable de entorno `BENCHER_ADAPTER` al nombre del adaptador deseado. (ej: `BENCHER_ADAPTER: json`) Si no se establece esto, entonces se utilizar√° el adaptador `magic`. Consulte [adaptadores de arn√©s de benchmark](/docs/es/explanation/adapters) para obtener una visi√≥n completa.
8. Haz una copia de tu c√≥digo fuente. (ej: `uses: actions/checkout@v3`)
9. Instala la CLI de Bencher utilizando la [Acci√≥n de GitHub](https://github.com/marketplace/actions/bencher-cli). (ej: `uses: bencherdev/bencher@main`)
10. [Rastrea tus benchmarks](/docs/es/how-to/track-benchmarks) con el subcomando CLI <code><a href="/docs/es/explanation/bencher-run">bencher run</a></code>:
    1.  Opcional: Configura la bandera `--branch` o la variable de entorno `BENCHER_BRANCH` a la representaci√≥n √∫nica o UUID de la rama. (ej: `--branch main`) La rama **debe** existir previamente. Si no se establece esto, entonces se utilizar√° la rama `main`.
    2.  Establece el comando para fallar si se genera una Alerta. (ej: `--err`) Para que se genere una Alerta, un [Umbral](/docs/es/explanation/thresholds) debe existir previamente.
    3.  Ejecuta tus benchmarks y genera un informe a partir de los resultados. (ej: `"bencher mock"`)

<br/>

## Pull Requests

Para detectar la regresi√≥n del rendimiento en los Pull Requests, necesitar√°s ejecutar tus benchmarks en PRs.
Si solo esperas tener PRs de ramas dentro del **mismo** repositorio, entonces puedes simplemente modificar el ejemplo anterior para tambi√©n ejecutar `on` eventos `pull_request`.

> ‚ö†Ô∏è ¬°Esta soluci√≥n solo funciona si todos los PRs son del **mismo** repositorio!
> Consulta [Pull Requests de Forks](#pull-requests-from-forks) a continuaci√≥n.

<GitHubActions2 />

1. Crea un archivo de `workflow` para GitHub Actions. (ej: `.github/workflows/pr_benchmarks.yml`)
2. Ejecutar en eventos de `pull_request` solo si la solicitud de extracci√≥n proviene del mismo repositorio. Para gestionar PRs de Forks, vea [Solicitudes de extracci√≥n de Forks](#solicitudes-de-extracci√≥n-de-forks) a continuaci√≥n.
3. [Selecciona la rama](http://localhost:3000/docs/es/explanation/branch-selection) a utilizar:
        1. Usar los datos de la rama actual si ya existen. (ej: `--if-branch '${{ github.head_ref }}'`)
        2. Crear un clon de los datos y umbrales de la rama objetivo de la PR si ya existen. (ej: `--else-if-branch '${{ github.base_ref }}'`)
        3. De lo contrario, crea un clon de los datos y umbrales de la rama `main`. (ej: `--else-if-branch main`)
4. Configurar el token de autenticaci√≥n de la API de GitHub. (ej: `--github-actions "${{ secrets.GITHUB_TOKEN }}"`) Cuando esta opci√≥n se establece como parte de una solicitud de extracci√≥n, entonces los resultados se a√±adir√°n a la solicitud de extracci√≥n como un comentario. Esto utiliza [la variable de entorno `GITHUB_TOKEN` de GitHub Actions](https://docs.github.com/es/actions/security-guides/automatic-token-authentication).
5. Consulta la documentaci√≥n de [ejecuci√≥n de bencher](/docs/es/explanation/bencher-run) para obtener una visi√≥n general completa de todas las formas de configurar el comentario de solicitud de extracci√≥n con las banderas `--ci-*`.
6. (No mostrado) Crea un segundo archivo de `workflow` para GitHub Actions y utiliza el ejemplo inicial de arriba para ejecutar en eventos `push` a la rama `main`. (ej: `.github/workflows/benchmarks.yml`)

## Pull Requests desde Forks

Si planeas aceptar pull requests desde forks, como suele ser el caso en proyectos de c√≥digo abierto p√∫blicos,
entonces tendr√°s que manejar las cosas un poco diferente.
Por razones de seguridad, secretos como tu `BENCHER_API_TOKEN` y el `GITHUB_TOKEN` no est√°n disponibles en GitHub Actions para PRs de forks.
Es decir, si un colaborador externo abre un PR desde un fork, el ejemplo anterior no funcionar√°.
Hay dos opciones para PRs de forks:

<ul>
  <li>[Benchmark Fork PR desde la Rama Objetivo con Revisores Requeridos](#benchmark-fork-pr-from-target-branch-with-required-reviewers)</li>
  <li>[Benchmark Fork PR y Subida desde la Rama Default](#benchmark-fork-pr-and-upload-from-default-branch)</li>
</ul>

### Benchmark Fork PR desde la Rama Objetivo con Revisores Requeridos

> ‚ö†Ô∏è Es **muy**, **muy** importante revisar a fondo cualquier PR de bifurcaci√≥n antes de aprobarlo!
> No hacerlo podr√≠a resultar en una petici√≥n pwn!
>
> Si prefieres no tener eso sobre tu cabeza, consulta [Benchmark Fork PR y Carga desde la Rama Default](#benchmark-fork-pr-y-carga-desde-la-rama-default) a continuaci√≥n.

<GitHubActions3 />

1. Crea un archivo `workflow` de GitHub Actions. (ej: `.github/workflows/pr_benchmarks.yml`)
1. Ejecuta [en los eventos `pull_request_target`](https://docs.github.com/es/actions/using-workflows/events-that-trigger-workflows#pull_request_target).
1. Crea un `job` llamado `fork_pr_requires_review` que requiere la aprobaci√≥n de un Revisor Requerido antes de cada ejecuci√≥n de pull request de fork (`external`).
1. Crea un tercer `job` que depende de `fork_pr_requires_review`.
   1. Haz checkout de la rama del pull request pero no persistas las credenciales de git. (ej: `persist-credentials: false`)
   2. Usa comillas simples alrededor de todas las entradas no confiables. (ej: `--if-branch '${{ github.head_ref }}'`)
   3. Pasa todos los secretos directamente. (ej: `--token "${{ secrets.BENCHER_API_TOKEN }}"`)
   4. Ejecuta y rastrea tus benchmarks de pull request con `bencher run`.
1. (No se muestra) Crea un segundo archivo `workflow` de GitHub Actions y usa el ejemplo inicial de arriba para ejecutar en eventos `push` a la rama `main`. (ej: `.github/workflows/benchmarks.yml`)

Esta configuraci√≥n funciona porque `pull_request_target` se ejecuta en el contexto de la rama objetivo del pull request,
donde los secretos como tu `BENCHER_API_TOKEN` y el `GITHUB_TOKEN` est√°n disponibles.
Por lo tanto, este flujo de trabajo solo se ejecutar√° si existe en la rama _objetivo_.

Para configurar esto, necesitas [crear dos Entornos de Acci√≥n de GitHub](https://docs.github.com/es/actions/deployment/targeting-different-environments/using-environments-for-deployment#using-an-environment)
(ej: `Repo -> Settings -> Environments -> New environment`).
El entorno `internal` no debe tener ninguna `Regla de protecci√≥n de despliegue`.
Sin embargo, el entorno `external` debe tener `Revisores requeridos` establecido para aquellos que pueda confiar para revisar los PRs de fork antes de benchmarking.

Es muy importante envolver el nombre de la rama de PR (referencia de cabeza) en comillas **simples**. (ej: `--if-branch '${{ github.head_ref }}'`) De lo contrario, un atacante podr√≠a crear una rama con nombre malicioso que realice inyecci√≥n de comando. Consulta este [informe del Laboratorio de Seguridad de GitHub](https://securitylab.github.com/research/github-actions-untrusted-input/) sobre c√≥mo evitar solicitudes pwn de entrada no confiable para una visi√≥n completa.

Evita configurar cualquier secreto como variables de entorno, como `GITHUB_TOKEN` y `BENCHER_API_TOKEN`.
En lugar de eso, p√°salos expl√≠citamente a `bencher run`. (ej: `--token "${{ secrets.BENCHER_API_TOKEN }}"`)
Consulta este [informe del Laboratorio de Seguridad de GitHub](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)
y [este post de blog](https://nathandavison.com/blog/github-actions-and-the-threat-of-malicious-pull-requests)
sobre c√≥mo evitar solicitudes pwn para una visi√≥n completa.

### Benchmark Fork PR y Subida desde la Rama Default

<GitHubActions4 />

1. Crea un archivo de flujo de trabajo `Run and Cache Benchmarks`. (ej: `.github/workflows/pr_benchmarks.yml`)
2. Ejecuta todos los trabajos en el flujo de trabajo en eventos de `pull_request`.
3. Ejecuta los benchmarks y guarda los resultados en un archivo. (ej: `benchmark_results.json`)
4. Sube el archivo de resultados de benchmark como un artefacto.
5. Sube el objeto de evento `pull_request` como un artefacto.

<GitHubActions5 />

1. Crea un segundo archivo de flujo de trabajo, `Track Benchmarks`. (ej: `.github/workflows/track_benchmarks.yml`)
2. A√±ade al flujo de trabajo `Track Benchmarks` a `Run and Cache Benchmarks` con [el evento `workflow_run`](https://docs.github.com/es/actions/using-workflows/events-that-trigger-workflows#workflow_run).
3. Descarga los resultados de benchmark almacenados en cach√© y el evento `pull_request`.
4. Extrae los resultados del benchmark almacenados en cach√© y el evento `pull_request`.
5. Exporta los datos necesarios del evento `pull_request` como variables de entorno.
6. Rastrea los resultados del benchmark almacenados en cach√© con `bencher run`:
   1. Usar comillas simples alrededor de toda la entrada no confiable. (ej: `--if-branch '${{ env.PR_HEAD }}'`)
   2. Pasar expl√≠citamente el n√∫mero de pull request. (ej: `--ci-number '${{ env.PR_NUMBER }}'`)
   3. Pasar el camino al archivo de resultados de benchmark. (ej: `--file "$BENCHMARK_RESULTS"`)
1. (No se muestra) Crea un tercer archivo de flujo de trabajo de GitHub Actions y usa el ejemplo inicial de arriba para ejecutar en eventos de `push` a la rama `main`. (ej: `.github/workflows/benchmarks.yml`)

Esta configuraci√≥n funciona porque `workflow_run` se ejecuta en el contexto de la rama default del repositorio,
donde los secretos como tu `BENCHER_API_TOKEN` y el `GITHUB_TOKEN` est√°n disponibles.
Por lo tanto, estos flujos de trabajo solo se ejecutar√°n si existen en la rama _default_.
Consulte [usando datos del flujo de trabajo de disparo](https://docs.github.com/es/actions/using-workflows/events-that-trigger-workflows#using-data-from-the-triggering-workflow) para obtener una visi√≥n completa.
El n√∫mero de pull request, la rama de cabeza y la rama base utilizados en el flujo de trabajo inicial deben pasarse expl√≠citamente ya que no est√°n disponibles dentro de `workflow_run`.

Es muy importante envolver el nombre de la rama de PR (referencia de cabeza) en comillas **simples**. (ej: `--if-branch '${{ env.PR_HEAD }}'`) De lo contrario, un atacante podr√≠a crear una rama con nombre malicioso que realice inyecci√≥n de comando. Consulta este [informe del Laboratorio de Seguridad de GitHub](https://securitylab.github.com/research/github-actions-untrusted-input/) sobre c√≥mo evitar solicitudes pwn de entrada no confiable para una visi√≥n completa.

Evita configurar cualquier secreto como variables de entorno en el archivo de flujo de trabajo `Run and Cache Benchmarks`.
Consulta este [escribo del Laboratorio de Seguridad de GitHub](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)
y [este post de blog](https://nathandavison.com/blog/github-actions-and-the-threat-of-malicious-pull-requests)
sobre c√≥mo evitar solicitudes pwn para una visi√≥n completa.

<br/>
<br/>

> üê∞ ¬°Felicidades! ¬°Has aprendido a usar Bencher en GitHub Actions! üéâ

<br/>

<h2><a href="/docs/es/explanation/benchmarking">Contin√∫a: Visi√≥n General del Benchmarking ‚û°</a></h2>
